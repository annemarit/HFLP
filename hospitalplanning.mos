!ETASJER

model HospitalPlanning

options explterm
options noimplicit

uses "mmxprs";
uses "mmsystem";

parameters
	DataFile      = 'datafil.txt';
	ConfFile      = 'Configs.txt';
	ProximityFile = 'Proximity.txt';
	AllowedFile   = 'AllowedConfigurations.txt';
end-parameters

declarations
	starttime:   real;
	endtime:     real;
	usedtime:    real;
end-declarations

!Declaring the sizes of the sets
declarations
	niLocations:        integer;	
	njLocations:        integer;
	nFloors:            integer;	
	nFunctions:         integer;
	nConfigurations:    integer;
	nPerspectives:      integer;
	nMaxSize:           integer;
	nElevators:         integer;
end-declarations

!Initializing the sizes of the sets
initializations from DataFile
	niLocations;	
	njLocations;
	nFloors;	
	nFunctions;
	nPerspectives;
	nElevators;
end-initializations

!Configs
initializations from ConfFile
	nMaxSize;
	nConfigurations;
end-initializations

!Declaring the sets
declarations
	iLocations:                 set of integer;	
	jLocations:                 set of integer;
	Floors:                     set of integer;	
	ArtificialiLocations:       set of integer;	
	ArtificialjLocations:       set of integer;	
	Functions:                  set of integer;
	Configurations:             set of integer;
	Size:                       set of integer;
	Perspectives:               set of integer;
	Elevators:                  set of integer;
end-declarations

!Assigning values to the sets
iLocations                  :=  1 .. niLocations;
jLocations                  :=  1 .. njLocations;
Floors                      :=  1 .. nFloors;
ArtificialiLocations        := -2 .. niLocations + 3;
ArtificialjLocations        := -2 .. njLocations + 3;
Functions                   :=  1 .. nFunctions;
Configurations              :=  1 .. nConfigurations;
Perspectives                :=  1 .. nPerspectives;
Size                        :=	1 .. nMaxSize;
Elevators                   :=  1 .. nElevators;

finalize(Size);

!Declaring configurations
declarations
	Conf = record
		ii : dynamic array(Size) of integer;
		jj : dynamic array(Size) of integer;
	end-record;
	Configs: dynamic array(Size, integer) of Conf;
end-declarations

initializations from ConfFile
	Configs;
end-initializations

!Declaring the parameters
declarations
	Distance:               dynamic array(iLocations, jLocations, Floors, iLocations, jLocations, Floors) of integer;
	Proximity:              dynamic array(Perspectives, Functions, Functions)                             of integer;
	SizeFunction:           array(Functions)                                                              of integer;
	ConfigurationCount:     array(Size)                                                                   of integer;
	LockVariable:           dynamic array(Functions, iLocations, jLocations, Floors)                      of integer;
	LockCoverVariable:      dynamic array(Functions, iLocations, jLocations, Floors)                      of integer;
	LockVariableConfig:     dynamic array(Functions, iLocations, jLocations, Floors, Configurations)      of integer;
	LockFloorVariable:      dynamic array(Functions, Floors)                                              of integer;
	LockWall:               dynamic array(Functions)                                                      of integer;
	Weights:                array(Perspectives)                                                           of real;
	Footprint:              array(jLocations, iLocations)                                                 of integer;
	WeightedProximity:      dynamic array(Functions, Functions)                                           of real;
	ElevatorPlacement:      dynamic array(Elevators, iLocations, jLocations)                              of integer;
end-declarations

!Initializing the parameters
initializations from DataFile
	SizeFunction;
	LockVariable;
	LockCoverVariable;
	LockVariableConfig;
	LockFloorVariable;
	LockWall;
	Weights;
	Footprint;
	ElevatorPlacement;
end-initializations

initializations from ConfFile
	ConfigurationCount;
end-initializations

initializations from ProximityFile
	Proximity;
end-initializations

!Declaring the subsets of functions (functions of different sizes and configurations of functions)
declarations
	FunctionSize:               dynamic array(Size)         of set of integer;
	FunctionConfiguration:      dynamic array(Functions)    of set of integer;
	iIndicator:				    dynamic array(Elevators)    of integer;
	jIndicator:				    dynamic array(Elevators)    of integer;
	ElevatorDistance:			dynamic array(iLocations, jLocations, Floors, Elevators, iLocations, jLocations, Floors)   of integer;
end-declarations

!Calculating distances between Locations
forall(ii in iLocations, jj in jLocations, qq in Floors) do
	forall (kk in iLocations, ll in jLocations, rr in Floors) do
		if (qq = rr) then
			Distance(ii,jj,qq,kk,ll,rr) := abs(kk-ii) + abs(ll-jj);
		elif (qq <> rr) then
			forall(ee in Elevators) do
				if(ElevatorPlacement(ee,ii,jj)=1) then
					iIndicator(ee):=ii;
					jIndicator(ee):=jj;	
				end-if
				ElevatorDistance(ii,jj,qq,ee,kk,ll,rr):= abs(ii-iIndicator(ee)) + abs(jj-jIndicator(ee)) + abs(rr-qq)
				                                         + abs(iIndicator(ee)-kk) + abs(jIndicator(ee)-ll);
			end-do
			Distance(ii,jj,qq,kk,ll,rr) := min(ee in Elevators) 1*ElevatorDistance(ii,jj,qq,ee,kk,ll,rr);
		end-if
	end-do
end-do

!Creating WeightedProximity
forall(ff in Functions, gg in Functions | ff<gg) do
		WeightedProximity(ff, gg) := sum(pp in Perspectives) Weights(pp) * Proximity (pp, ff, gg);
end-do

!Creating FunctionSize
forall(ss in Size) do
	forall(ff in Functions) do
		if (SizeFunction(ff)=ss) then
			FunctionSize(ss) += {ff};
		end-if
	end-do
end-do

!Creating FunctionConfiguration
forall(ff in Functions) do
	forall(mm in 1..ConfigurationCount(SizeFunction(ff))) do
		FunctionConfiguration(ff) += {mm};
	end-do
end-do

!Declaring UsedSquares (marks the squares that is covered when a centre node with a given configuration is placed at a location)
declarations
	UsedSquares:         dynamic array(Size, Configurations, ArtificialiLocations, ArtificialjLocations,
		                               Floors, ArtificialiLocations, ArtificialjLocations, Floors)          of integer;
end-declarations

!Creating UsedSquares for sizes ss and configurations mm
forall (ss in Size, cc in 1..getsize(Configs) | exists(Configs(ss,cc))) do
	forall (ww in Size | exists(Configs(ss,cc).ii(ww))) do
		forall (ii in iLocations, jj in jLocations, qq in Floors) do
			UsedSquares(ss, cc, ii, jj, qq, ii + Configs(ss,cc).ii(ww), jj + Configs(ss,cc).jj(ww), qq) := 1;
		end-do
	end-do
end-do

!Declaring AllowedPlacement (in which locations (i,j) on the grid different configurations m of sizes s can be placed)
declarations
	AllowedPlacement:       dynamic array(Size, Configurations, iLocations, jLocations, Floors)     of integer;
	AllowedConfig:          dynamic array(Functions, Configurations)                                of integer;
end-declarations

initializations from AllowedFile
	AllowedConfig;
end-initializations

!Creating AllowedPlacement. AllowedPlacement(ss,mm,ii,jj) is equal to 1 if the function can be placed there.
forall (ss in Size, mm in 1..ConfigurationCount(ss)) do
	forall (ii in iLocations, jj in jLocations, qq in Floors) do
		AllowedPlacement(ss,mm,ii,jj,qq) := 1;
		if (ii < 1 or ii > niLocations or jj < 1 or jj > njLocations) then
			AllowedPlacement(ss,mm,ii,jj,qq) := 0;
		end-if
		forall(kk in (ii-2)..(ii+2), ll in (jj-2)..(jj+2)) do
			if (UsedSquares(ss,mm,ii,jj,qq,kk,ll,qq) = 1) then
				if (kk < 1 or kk > niLocations or ll < 1 or ll > njLocations) then
					AllowedPlacement(ss,mm,ii,jj,qq) := 0;
				end-if
			end-if
		end-do
	end-do
end-do

!Writing out the size of each function
writeln(' ');
writeln('The grid is of size ixj: ' + niLocations + 'x' + njLocations);
writeln("----------------------------------------------------------------------");
writeln(' ');

!Creating a matrix for X (1 where functions can be placed/0 where functions are locked)
declarations
	Xplace:		dynamic array(Functions, iLocations, jLocations, Floors) of integer;
end-declarations  

forall (ff in Functions, ii in iLocations, jj in jLocations, qq in Floors) do
	Xplace(ff,ii,jj,qq) := 1;
end-do

forall (ff in Functions, ii in iLocations, jj in jLocations, qq in Floors) do
	!Elevator
	forall (ee in Elevators) do
		if (ElevatorPlacement(ee,ii,jj)=1) then
				Xplace(ff,ii,jj,qq) := 0; !No function can be placed at the elevators location
		end-if
	end-do
	!LockVariable
	if (LockVariable(ff,ii,jj,qq) = 1) then
		writeln("The centre of Function ",ff, "is locked to Location (",ii, ",", jj, ") on floor ",qq);
		forall (f2 in Functions | f2 <> ff) do
			Xplace(f2,ii,jj,qq) := 0; !All other functions than the locked function can not be placed at this location
		end-do
		forall (i2 in iLocations, j2 in jLocations, q2 in Floors | i2 <> ii or j2 <> jj or q2 <> qq) do
			Xplace(ff,i2,j2,q2) := 0; !The locked function can not be placed in any other locations
		end-do
	end-if
	!LockVariableConfig
	forall (cc in FunctionConfiguration(ff)) do
		if (LockVariableConfig(ff,ii,jj,qq,cc) = 1) then
			writeln("The centre of Function ",ff, " is locked to Location (",ii, ",", jj, ") on floor ", qq, " with Configuration ",cc );
			forall (f2 in Functions | f2 <> ff) do !All other functions than the locked function
				forall (kk in iLocations, ll in jLocations) do !And all locations
					if (UsedSquares(SizeFunction(ff),cc,ii,jj,qq,kk,ll,qq) = 1) then
						Xplace(f2,kk,ll,qq) := 0; !All other functions than the locked function can not be placed at this location
					end-if
				end-do
			end-do
			forall (i2 in iLocations, j2 in jLocations, q2 in Floors | i2 <> ii or j2 <> jj or q2 <> qq) do
				Xplace(ff,i2,j2,q2) := 0; !The locked function can not be placed in any other locations
			end-do
		end-if
	end-do
	!LockCoverVariable
	if (LockCoverVariable(ff,ii,jj,qq) = 1) then
		writeln("Function ",ff, " covers Location (",ii, ",", jj,") on floor ",qq);
		forall (f2 in Functions | f2 <> ff) do
			Xplace(f2,ii,jj,qq) := 0;
		end-do
	end-if
	!LockFloorVariable
	if (LockFloorVariable(ff,qq)=1) then
		forall (q2 in Floors | q2 <> qq) do
			Xplace(ff,ii,jj,q2) := 0;
		end-do
	end-if
end-do

!Illustrating which locations are locked
writeln('Illustrating which locations each functions can be placed');
writeln('1 = possible to place function at location (i,j)/0= not possible to place function');
writeln;
forall (ff in Functions) do
	writeln;
	writeln("Function ", ff);
	forall (qq in Floors) do
		writeln("Floor ",qq);
		forall (jj in jLocations) do
			forall (ii in iLocations) do
				write(strfmt(Xplace(ff,ii,njLocations-jj+1,qq),2));
			end-do
			writeln;
		end-do
	end-do
end-do
writeln;

!Declaring the variables
declarations
	centrePlacement:    dynamic array(Functions, ArtificialiLocations, ArtificialjLocations, Floors, Configurations) of mpvar; !x
	centrePlacement2:   dynamic array(Functions, ArtificialiLocations, ArtificialjLocations, Floors)                 of mpvar; !w
	elementCovered:     dynamic array(Functions, ArtificialiLocations, ArtificialjLocations, Floors)                 of mpvar; !v
	relationPlacement:  dynamic array(Functions, ArtificialiLocations, ArtificialjLocations, Floors, Functions,
                        ArtificialiLocations, ArtificialjLocations, Floors)                                          of mpvar; !y
end-declarations

!setparam("XPRS_VERBOSE",true);

!Creating the binary variables x_fijm
forall (ff in Functions, ii in iLocations, jj in jLocations, qq in Floors, mm in FunctionConfiguration(ff)) do
	if (AllowedPlacement(SizeFunction(ff),mm,ii,jj,qq)=1 and AllowedConfig(ff,mm)=1 and Footprint(jj,ii)=1
		and Xplace(ff,ii,jj,qq)=1) then
		create(centrePlacement(ff,ii,jj,qq,mm));
		centrePlacement(ff,ii,jj,qq,mm) is_binary;
		if (LockVariableConfig(ff,ii,jj,qq,mm)=1) then
			centrePlacement(ff,ii,jj,qq,mm) = 1;
		end-if
	end-if
end-do	

!Creating the binary variables v_fij and w_fij
forall (ff in Functions, ii in iLocations, jj in jLocations, qq in Floors) do
	if (Footprint(jj,ii)=1 and sum(ee in Elevators) 1*ElevatorPlacement(ee,ii,jj)=0) then
		!Creating v_fij
		if (not LockWall(ff)=1) then
			create(elementCovered(ff,ii,jj,qq));		
			elementCovered(ff,ii,jj,qq) is_binary;
			!Locking functions to cover a certain location at the grid
			if (LockCoverVariable(ff,ii,jj,qq)=1) then
				elementCovered(ff,ii,jj,qq)=1;
			end-if
		else
			if (ii = 1 or jj = 1 or ii = niLocations or jj = njLocations) then
				create(elementCovered(ff,ii,jj,qq));		
				elementCovered(ff,ii,jj,qq) is_binary;
				!Locking functions to cover a certain location at the grid
				if (LockCoverVariable(ff,ii,jj,qq)=1) then
					elementCovered(ff,ii,jj,qq)=1;
				end-if
			end-if
		end-if
		!Creating w_fij
		if (Xplace(ff,ii,jj,qq)=1) then
			create(centrePlacement2(ff,ii,jj,qq));
			centrePlacement2(ff,ii,jj,qq) is_binary;
			if (LockVariable(ff,ii,jj,qq)=1) then
				centrePlacement2(ff,ii,jj,qq) = 1;
			end-if
		end-if
	end-if
end-do

!Creating the binary variables y_fijgkl
forall (ff in Functions, ii in iLocations, jj in jLocations, qq in Floors, gg in Functions, kk in iLocations,
		ll in jLocations, rr in Floors | exists(centrePlacement2(ff, ii, jj, qq)) and exists(centrePlacement2(gg, kk, ll, rr))) do
	if (ff < gg and (ii <> kk or jj <> ll or qq <> rr) and not(WeightedProximity(ff,gg)=0)) then
		create(relationPlacement(ff, ii, jj, qq, gg, kk, ll, rr));
		relationPlacement(ff,ii,jj,qq,gg,kk,ll,rr) is_binary;
	end-if
end-do

!CentrePlacementBlock tells which locations (a,b) the centre of a function can be placed to cover a location (i,j) on the grid
declarations
	CentrePlacementBlock:   dynamic array(Functions, iLocations, jLocations, Floors, Configurations,
                                          ArtificialiLocations, ArtificialjLocations)           of integer;
end-declarations

!Creating CentrePlacementBlock for sizes ss and configurations mm
forall (ff in Functions) do
    forall (ii in iLocations, jj in jLocations, qq in Floors) do      
		forall (cc in 1..getsize(Configs) | exists(Configs(SizeFunction(ff),cc)) and cc in FunctionConfiguration(ff)) do
			forall (ww in Size | exists(Configs(SizeFunction(ff),cc).ii(ww))) do
				CentrePlacementBlock(ff,ii,jj,qq,cc,ii-Configs(SizeFunction(ff),cc).ii(ww),jj-Configs(SizeFunction(ff),cc).jj(ww)):=1;
			end-do
		end-do
	end-do
end-do

!Declaration the objective function and constraints
declarations
	TotalDistanceProximity:     linctr;
	helpCon:                    dynamic array(Functions, iLocations, jLocations, Floors)        of linctr;
	nonOverlapCon:              dynamic array(iLocations, jLocations, Floors)                   of linctr;
	allFunctionsPlacedCon:      dynamic array(Functions)                                        of linctr;
	linearizationCon:           dynamic array(Functions, iLocations, jLocations, Floors,
	                            Functions, iLocations, jLocations, Floors)                      of linctr;
	yLimitCon:                  dynamic array(Functions, Functions)                             of linctr;
	centrePlacementCon:	        dynamic array(Functions, iLocations, jLocations, Floors)        of linctr;
end-declarations

!Objective function good
TotalDistanceProximity :=
	sum (ff in Functions, ii in iLocations, jj in jLocations, qq in Floors, gg in Functions, kk in iLocations, ll in jLocations,
		 rr in Floors | ff < gg)
		WeightedProximity(ff,gg) * Distance(ii,jj,qq,kk,ll,rr) * relationPlacement(ff,ii,jj,qq,gg,kk,ll,rr);

!Constraint (2)
forall (ff in Functions, ii in iLocations, jj in jLocations, qq in Floors) do
	helpCon(ff, ii, jj, qq) :=
		sum(mm in Configurations) centrePlacement(ff,ii,jj,qq,mm) - centrePlacement2(ff,ii,jj,qq) = 0.0;
end-do

!Constraint (3) good
forall (ii in iLocations, jj in jLocations, qq in Floors) do
	nonOverlapCon(ii, jj, qq) :=
		sum(ff in Functions) elementCovered(ff,ii,jj,qq) <= 1.0;
end-do

!Constraint (4) good
forall (ff in Functions) do
	allFunctionsPlacedCon(ff) :=
		sum(ii in iLocations, jj in jLocations, qq in Floors) centrePlacement2(ff,ii,jj,qq) = 1.0;
end-do

!Constraint (5)
forall (ff in Functions, ii in iLocations, jj in jLocations, qq in Floors, gg in Functions, kk in iLocations, ll in jLocations, rr in Floors | 
		ff < gg and exists(relationPlacement(ff,ii,jj,qq,gg,kk,ll,rr))) do
	linearizationCon(ff,ii,jj,qq,gg,kk,ll,rr) :=
		centrePlacement2(ff,ii,jj,qq) + centrePlacement2(gg,kk,ll,rr) - relationPlacement(ff,ii,jj,qq,gg,kk,ll,rr) <= 1.0;
end-do

!Constraint (6) - sum of y = 1
forall (ff in Functions, gg in Functions | ff < gg and sum(ii in iLocations, jj in jLocations, qq in Floors, kk in iLocations, ll in jLocations, rr in Floors |
		exists(relationPlacement(ff,ii,jj,qq,gg,kk,ll,rr)))1 >= 1) do
	yLimitCon(ff,gg) :=
	sum(ii in iLocations, jj in jLocations, qq in Floors, kk in iLocations, ll in jLocations, rr in Floors)
	    relationPlacement(ff,ii,jj,qq,gg,kk,ll,rr) = 1.0;
end-do

!Constraint (8)
forall(ff in Functions, ii in iLocations, jj in jLocations, qq in Floors) do
	centrePlacementCon(ff,ii,jj,qq) :=
		sum(mm in FunctionConfiguration(ff), aa in ii-2..ii+2, bb in jj-2..jj+2 | CentrePlacementBlock(ff,ii,jj,qq,mm,aa,bb) = 1)
		centrePlacement(ff,aa,bb,qq,mm) = elementCovered(ff,ii,jj,qq);
end-do

starttime := gettime;

!Minimizes the function
minimize(TotalDistanceProximity);

endtime := gettime;

usedtime := endtime - starttime;
!fopen("output.dat", F_OUTPUT+F_APPEND);
!writeln(' Run time: ' + usedtime);

!Writes functions with configurations that are placed in coordinate (i,j)
writeln("----------------------------------------------------------------------");
writeln(" Objective value: ", getobjval);
writeln("----------------------------------------------------------------------");
writeln("");
writeln("The following functions are placed on the grid:");
writeln("");
forall(ff in Functions, ii in iLocations, jj in jLocations, qq in Floors, mm in Configurations) do
	if (getsol(centrePlacement(ff,ii,jj,qq,mm)) = 1) then
		writeln("The centre of Function " +ff+ " with configuration " +mm+ " is placed in ("+ii+","+jj+") on floor "+qq);
	end-if
end-do
writeln("");	
	
!Creates grid with functions
declarations
	OccupiedByFunction:      array(iLocations, jLocations, Floors)      of integer;
	ElevatorGrid:            dynamic array(iLocations, jLocations)      of integer;
end-declarations

forall (qq in Floors) do
	forall (ii in iLocations) do
		forall (jj in jLocations) do
			forall (ff in Functions) do
				forall (mm in 1..ConfigurationCount(SizeFunction(ff))) do
					if (getsol(centrePlacement(ff, ii, jj, qq, mm))=1.0) then
						forall(kk in (ii-2)..(ii+2), ll in (jj-2)..(jj+2)) do
							if (UsedSquares(SizeFunction(ff),mm,ii,jj,qq,kk,ll,qq)=1) then
								OccupiedByFunction(kk,ll,qq):=ff;
							end-if
						end-do
					end-if
				end-do
			end-do
		end-do
	end-do
end-do

forall (ee in Elevators, ii in iLocations, jj in jLocations) do
	if (ElevatorPlacement(ee,ii,jj)=1) then
		ElevatorGrid(ii,jj):=1;
	end-if
end-do	

!Visualizes grid with functions
writeln('Visualization of the functions placed on the grid:');
writeln(' ');
forall (qq in Floors) do
	writeln('Floor ',qq);
	forall (jj in jLocations) do
		forall (ii in iLocations) do
				if (ElevatorGrid(ii,njLocations-jj+1)=1) then
					write("E");
					write("  ");
				else
					if (OccupiedByFunction(ii,njLocations-jj+1,qq)>9) then
						write(OccupiedByFunction(ii,njLocations-jj+1,qq));
						write(" ");
					else
						write(OccupiedByFunction(ii,njLocations-jj+1,qq));
						write("  ");
					end-if
				end-if	
		end-do
		writeln;
	end-do
	writeln;
end-do
writeln(' ');
!fclose(F_OUTPUT);

end-model