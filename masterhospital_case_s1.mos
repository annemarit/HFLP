model MasterHospital
	
options explterm
options noimplicit

uses "mmxprs";
uses "mmsystem";

parameters
DataFile          = 'datafile_case_s1.txt';
ProximityFile     = 'proximity_case_s1.txt';
DistanceFile      = 'distances_case_s1.txt';
SpecificationFile = 'specifications_case_s1.txt';
NeighbourFile     = 'neighbours_case_s1.txt';
end-parameters

declarations
	starttime:   real;
	endtime:     real;
	usedtime:    real;
end-declarations

!Declaring sizes of sets
declarations
	nFunctions:           integer;
	nNodes:               integer;
	nPerspectives:        integer;
	nFloors:              integer;
end-declarations

initializations from DataFile
	nFunctions;
	nNodes;
	nPerspectives;
	nFloors;
end-initializations

!Declaring sets
declarations
	Functions:           set of integer;
	Nodes:               set of integer;
	Perspectives:        set of integer;
	Floors:              set of integer;
end-declarations

!Assigning values to the sets
Functions    :=  1..nFunctions;
Nodes        :=  1..nNodes;
Perspectives :=  1..nPerspectives;
Floors       :=  1..nFloors;

!Declaring the parameters
declarations
	AreaFunctions:                   array(Functions)                                       of integer;
	RealAreaLocations:               array(Nodes)                                           of integer;
	AreaLocations:                   array(Nodes)                                           of real;
	DistanceNodes:                   dynamic array(Nodes, Nodes)                            of integer;
	DistanceFloors:                  dynamic array(Floors, Floors)                          of integer;
	Weights:                         array(Perspectives)                                    of real;
	Proximity:                       dynamic array(Perspectives, Functions, Functions)      of integer;
	WeightedProximity:               dynamic array(Functions, Functions)                    of real;
	NodesFloors:                     dynamic array(Nodes)                                   of set of integer;
	FloorsNodes:                     array(Nodes)                                           of integer;
	Windows:                         array(Nodes)                                           of integer;
	Oceanview:                       array(Nodes)                                           of integer;
	AreasFloors:			    	 array(Floors, Nodes)                                   of integer;
	FunctionsWindows:                dynamic array(Functions)                               of integer;
	FunctionsOceanview:              dynamic array(Functions)                               of integer;
	LockFloor:                       dynamic array(Floors, Functions)                       of integer;
	LockNotFloor:                    dynamic array(Floors, Functions)                       of integer;
	LockedFunctionsCentre:           dynamic array(Functions)                               of integer;
	LockedFunctions:                 dynamic array(Functions, Nodes)                        of integer;
	LockSameFloor:                   dynamic array(Functions, Functions)                    of integer;
	NodesAreaIncrease:                                                                      real;
	NeighbourNodes:                  dynamic array(Nodes)                                   of set of integer;
end-declarations

!Initializing the parameters
initializations from DataFile
	Weights;
	AreaFunctions;
	RealAreaLocations;
	NodesAreaIncrease;
end-initializations	

initializations from ProximityFile
	Proximity;
end-initializations

initializations from NeighbourFile
	NeighbourNodes;
end-initializations

initializations from SpecificationFile
	Windows;
	Oceanview;
	AreasFloors;
	FunctionsWindows;
	FunctionsOceanview;
	LockFloor;
	LockNotFloor;
	LockedFunctionsCentre;
	LockedFunctions;
	LockSameFloor;
end-initializations



!Creating WeightedProximity
forall (ff in Functions, gg in Functions | ff < gg) do
		WeightedProximity(ff, gg) := sum(pp in Perspectives) Weights(pp) * Proximity (pp, ff, gg);
end-do

!Creating subset NodesFloor (N^e)
forall (ee in Floors, ii in Nodes) do
	if (AreasFloors(ee,ii)=1) then
		NodesFloors(ee) += {ii};
	end-if
end-do

!Creating DistanceFloors
forall (ee in Floors, dd in Floors) do
	DistanceFloors(ee,dd) := abs(ee-dd);
end-do

!Creating DistanceNodes
forall (ee in Floors, ii in Nodes) do
	if (AreasFloors(ee,ii)=1) then
		FloorsNodes(ii) := ee;
	end-if
end-do
forall(ee in Floors) do
	forall (ii in Nodes, jj in Nodes) do
		DistanceNodes(ii,jj) := abs(FloorsNodes(ii)-FloorsNodes(jj));
	end-do
end-do		

!Adding extra margin to the area of locations
forall (ii in Nodes) do
	AreaLocations(ii) := NodesAreaIncrease*RealAreaLocations(ii);
end-do

!Creating Xplace: 1 where functions can be placed/=0 if functions can not be placed there)
declarations
	Xplace:			         dynamic array(Functions, Nodes)              of integer;
	NeighboursOfNeighbours:  dynamic array(Nodes)                         of set of integer;
end-declarations  

forall (ff in Functions, ii in Nodes) do
	Xplace(ff,ii) := 1;
end-do

forall (ff in Functions) do
	!Floors
	forall (ee in Floors) do
		if (LockFloor(ee,ff) = 1) then
			forall (e2 in Floors | e2<>ee) do
				forall (ii in NodesFloors(e2)) do
						Xplace(ff,ii) := 0;
				end-do
			end-do
		end-if
		if (LockNotFloor(ee,ff) = 1) then
			forall (ii in NodesFloors(ee)) do
				Xplace(ff,ii) := 0;
			end-do
		end-if
	end-do
	!Locked centre/neighbours
	forall (ii in Nodes) do
		if (LockedFunctionsCentre(ff)>0.5) then
			forall(i2 in Nodes | i2<>LockedFunctionsCentre(ff) and not exists(NeighbourNodes(ii))) do
				Xplace(ff,i2) := 0;
			end-do
		end-if
	!Locked w (placement of function) If not neighbours or neighbours to the possible centre locations
		if (LockedFunctions(ff,ii)>=1) then
			forall (tt in NeighbourNodes(ii)) do
				forall (ss in NeighbourNodes(tt)) do
					NeighboursOfNeighbours(ii) += {ss};
				end-do
			end-do
			forall (i2 in Nodes | i2<>ii and (not exists(NeighbourNodes(ii)) or not exists(NeighboursOfNeighbours(ii)))) do
				Xplace(ff,i2) := 0;
			end-do
		end-if	
	end-do
	!Specifications (windows, oceanview etc.)
	if (FunctionsOceanview(ff)=1) then
		forall (ii in Nodes) do
			if (Oceanview(ii)=0) then
				Xplace(ff,ii) := 0;
			end-if
		end-do
	end-if
	if (FunctionsWindows(ff)=1) then
		forall (ii in Nodes) do
			if (Windows(ii)=0) then
				Xplace(ff,ii) := 0;
			end-if
		end-do
	end-if		
end-do		

!Declaring the variables
declarations
	FunctionsCentrePlacement:  dynamic array(Functions, Nodes)                    of mpvar; !x
	FunctionsPlacement:        dynamic array(Functions, Nodes)                    of mpvar; !w
	FunctionsCoverage:         dynamic array(Functions, Nodes)                    of mpvar; !t
	FloorRelationVariable:     dynamic array(Functions, Floors, Functions, Floors)of mpvar; !v
	FloorVariable:             dynamic array(Functions, Floors)                   of mpvar; !p
end-declarations	

fopen("output_case_s1.dat", F_OUTPUT+F_APPEND);
setparam("XPRS_VERBOSE",true);

!Creating the binary variables x_fi
forall (ff in Functions, ii in Nodes) do
	if (Xplace(ff,ii)=1) then
		create(FunctionsCentrePlacement(ff, ii));
		!FunctionsCentrePlacement(ff, ii) is_binary;
	end-if
	if (LockedFunctionsCentre(ff) = ii) then
		FunctionsCentrePlacement(ff,ii)>=1;
	end-if
end-do

!Creating the binary variables w_fi
forall (ff in Functions, ii in Nodes) do
	if (Xplace(ff,ii)=1) then
		create(FunctionsPlacement(ff, ii));
		FunctionsPlacement(ff, ii) is_binary;
	end-if
	if (LockedFunctions(ff, ii) = 1) then
		FunctionsPlacement(ff, ii) >= 1;
	end-if
end-do	

!Creating the variables t_fi
forall (ff in Functions, ii in Nodes | exists(FunctionsPlacement(ff, ii))) do
	create(FunctionsCoverage(ff, ii));
	FunctionsCoverage(ff, ii) >= 0;
end-do

!Creating the binary variables p_fe
forall (ff in Functions, ee in Floors) do
	create(FloorVariable(ff,ee));
	FloorVariable(ff,ee) is_binary;
end-do

!Creating the binary variables v_fegd
forall (ff in Functions, ee in Floors, gg in Functions, dd in Floors |
		exists(FloorVariable(ff,ee)) and exists(FloorVariable(gg,dd))) do
	if (ff<gg and (ee <> dd) and WeightedProximity(ff,gg)>0) then
		create(FloorRelationVariable(ff, ee, gg, dd));
	end-if		
end-do

!Lock functions to the same floor
forall(ff in Functions) do
	forall(gg in Functions) do
		forall (ee in Floors) do
			if (LockSameFloor(ff,gg)=1) then
				FloorVariable(ff,ee)=FloorVariable(gg,ee);
			end-if
		end-do
	end-do
end-do

writeln("------------------------------------------------------");

!Declaration the objective function and constraints
declarations
	TotalDistanceProximity:   linctr;
	Con1:                     dynamic array(Functions)                            of linctr;
	Con6:                     dynamic array(Nodes)                                of linctr;
	Con8:                     dynamic array(Functions, Nodes)                     of linctr;
	Con9:                     dynamic array(Functions, Nodes, Functions, Nodes)   of linctr;
	Con10:                    dynamic array(Functions, Nodes)                     of linctr;
	Con11a:                   dynamic array(Functions)                            of linctr;
	Con11b:                   dynamic array(Functions, Nodes)                     of linctr;
	Con12:                    dynamic array(Functions, Nodes)                     of linctr;
	Con13:                    dynamic array(Functions, Functions)                 of linctr;
	Con15:                    dynamic array(Functions)                            of linctr;
	Con17:                    dynamic array(Functions, Floors)                    of linctr;
	Con18:                    dynamic array(Floors)                               of linctr;
	Con19:                    dynamic array(Floors)                               of linctr;
	Con20:                    dynamic array(Floors)                               of linctr;
end-declarations

!Objective function
TotalDistanceProximity :=
	sum (ff in Functions, ee in Floors, gg in Functions, dd in Floors | ff < gg)
		WeightedProximity(ff,gg) * DistanceFloors(ee,dd) * FloorRelationVariable(ff, ee, gg, dd);

!Constraints (1)
forall (ff in Functions) do
	Con1(ff) :=
		sum(ii in Nodes) FunctionsCentrePlacement(ff,ii) = 1.0;
end-do

!Constraints (6)
forall (ii in Nodes) do
	Con6(ii) :=
		sum(ff in Functions) FunctionsCoverage(ff,ii) <= 1.0;
end-do

!Constraints (8)
forall (ff in Functions, ii in Nodes) do
	Con8(ff, ii) :=
		FunctionsCoverage(ff,ii) - FunctionsPlacement(ff,ii) <= 0.0;
end-do

!Constraints (9)
forall (ff in Functions, ee in Floors, gg in Functions, dd in Floors | ff < gg and exists(FloorRelationVariable(ff, ee, gg, dd))) do
	Con9(ff, ee, gg, dd) :=
	FloorVariable(ff,ee) + FloorVariable(gg,dd) - FloorRelationVariable(ff, ee, gg, dd) <= 1.0;
end-do	

!Constraints (10)
forall (ff in Functions, ii in Nodes) do
	Con10(ff, ii) :=
		FunctionsCentrePlacement(ff,ii) - FunctionsPlacement(ff,ii) <= 0.0;
end-do

!Constraints (12)
forall (ff in Functions, ii in Nodes) do
	Con12(ff, ii) :=
		FunctionsPlacement(ff, ii) <= FunctionsCentrePlacement(ff,ii) + sum(jj in NeighbourNodes(ii)) FunctionsCentrePlacement(ff,jj);
end-do

!Constraints (13)
forall (ff in Functions, gg in Functions | ff < gg and sum(ee in Floors, dd in Floors |
		exists(FloorRelationVariable(ff, ee, gg, dd)))1 >= 1) do
	Con13(ff,gg) :=
		sum(ee in Floors, dd in Floors) FloorRelationVariable(ff, ee, gg, dd) = 1.0;
end-do

!Constraints (15)
forall (ff in Functions) do
	Con15(ff) :=
		sum(ee in Floors) FloorVariable(ff,ee) = 1.0;
end-do

!Constraints (17)
forall (ff in Functions, ee in Floors) do
	Con17(ff,ee) :=
		FloorVariable(ff,ee) >= sum(ii in NodesFloors(ee)) FunctionsCentrePlacement(ff,ii);
end-do

!Constraints (18)
forall (ee in Floors) do
	Con18(ee) :=
		sum(ii in NodesFloors(ee), ff in Functions) AreaFunctions(ff)*FunctionsCentrePlacement(ff,ii) <= sum(ii in NodesFloors(ee)) AreaLocations(ii);
end-do

!Constraints (19)
forall (ee in Floors) do
	Con19(ee) :=
		sum(ii in NodesFloors(ee), ff in Functions) AreaFunctions(ff)*FunctionsWindows(ff)*FunctionsCentrePlacement(ff,ii) <= sum(ii in NodesFloors(ee)) Windows(ii)*AreaLocations(ii);
end-do
!Constraints (20)
forall (ee in Floors) do
	Con20(ee) :=
		sum(ii in NodesFloors(ee), ff in Functions) AreaFunctions(ff)*FunctionsOceanview(ff)*FunctionsCentrePlacement(ff,ii) <= sum(ii in NodesFloors(ee)) Oceanview(ii)*AreaLocations(ii);
end-do	


!-----------------------------------------------------------------------------------------------------

starttime := gettime;

!Minimizes the function
minimize(TotalDistanceProximity);

endtime := gettime;

usedtime := endtime - starttime;

writeln;
write("Date and time: ", datetime(SYS_NOW));
writeln;
writeln(' Run time: ' + usedtime);

writeln("");
writeln("Objective value: ", getobjval);
writeln("");

forall (ee in Floors) do
	write("Functions in floor ", ee, " are ");
	forall (ff in Functions) do
		if(getsol(FloorVariable(ff,ee))=1) then
			write(ff, " ");
		end-if
	end-do
	writeln;
	writeln("Total area of functions in floor ", ee, " is ", sum(ff in Functions, ii in NodesFloors(ee))
			AreaFunctions(ff)*getsol(FunctionsCentrePlacement(ff,ii)));
end-do

writeln;
writeln("LockFloor: ( Floors Functions ) 1");
forall (ee in Floors, ff in Functions) do
	if (getsol(FloorVariable(ff,ee))=1) then
		writeln("( ", ee, " ", ff, " ) 1");
	end-if
end-do

fclose(F_OUTPUT);

end-model
